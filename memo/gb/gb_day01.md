## JPA를 사용하는 이유?
객체와 RDB의 패러다임 불일치 문제

## 1. 상속    
   일반적으로 학생 테이블과 직장인 테이블 모델

   |학생|직장인|
   |:--:|:--:|
   |번호|번호|
   |이름|이름|
   |생년월일|생년월일|
   |학년|경력|
   |등급|직급|

### Extends ER모델
- 슈퍼(부모)
  |사람|
  |:--:|
  |번호(pk)|
  |이름|
  |생년월일|

- 서브(자식)

    |학생|직장인|
    |:--:|:--:|
    |번호(pk,fk)|번호(pk,fk)|
    |학년|경력|
    |등급|직급|

## 2. 연관관계
- 테이블의 연관관계   
  테이블을 서로 FK를 이용하여 관계를 맺는다.   
  FK를 사용하여 다른 테이블과 JOIN하여 연관된 테이블을 함께 조회한다.   
  그러므로 객체를 테이블에 맞추어 모델링하면 다음과 같다. 

  ```java
  
  //  기존 RDB에 맞춘 Dto 모델링 
  public class User{
    Long userNumber;
    String userName;
    String userId;
    String userPassword;
  }

  public class Board{
    Long boardNumber;
    String boardTitle;
    String boardContent;
    Long userNubmer;
  }

  ```

- 객체의 연관관계   
  객체의 연관관계는 참조값을 통해 이루어진다. 참조값에 하위 연산자(.)를 사용하면 참조가 된다. 그러므로 연관관계를 위해 외래키를 저장하는 것이 아니라 해당 객체의 참조값을 저장해야한다.   
  객체지향에 맞게 모델링하면 다음과 같다.

```java

//  객체지향에 맞춘 모델링 
class User{
   Long userNumber;
   String userName;
   String userId;
   String userPassword;
}

class Board{
   Long boardNumber;
   String boardTitle;
   String boardContent;
   User user;
}

```

## 3. 그래프 탐색
그래프 탐색이란 객체지향에서 사용되는 개념이다.   
자바 코드를 기준으로 게시글을 쓴 작성자를 찾고 싶다면 해당 Board객체와 연관된 User객체를 찾아야한다.   
이것을 객체 그래프 탐색이라고 하며 다음과 같이 찾을 수 있다.

`User user = board.getUser();`

다음과 같은 관계를 가졌다고 가정하자.   
```text
File----Board----User----UserProfile
              |
              |
          Reply
              |
              |
          ReplyFile
```
객체는 다음과 같이 마음대로 그래프를 탐색할 수 있어야한다.   

```java

board.getFile();
board.getUser().getUserProfile();
board.getReply().getReplyFile();

```

## 4. 비교
SQL에서 조회한 결과를 객체에 저장하면 같은 데이터를 조회하더라도 새로운 객체가 만들어지게 된다. 그렇기 때문에 객체의 주소가 다르며 == 을 통해 비교하면 같은 정보를 담고 있어도 false가 된다.

만약 자바의 컬렉션에 저장을 해놨다면 어땠을까?

```java

List<User> list = new ArrayList<User>();
      
      list.add(user);
      
      User user1 = list.get(0);
      User user2 = list.get(0);
      
      System.out.println(user1 == user2);

```

### 정리
이전의 RDB중심의 설계는 객체지향의 여러 장점을 포기하게 만들었다. 그래서 객발자들은 객체지향 설계를 적용하기 위해 시도를 많이 하였으나 객체지향으로 설계할 수록 복잡해지가 개발자가 할 일이 많아지게 되어 RDB중심의 설계로 변화될 수 밖에 없었다.   
오랜 노력 끝에 패러다임 불일치 문제를 해결할 수 있느 ORM기술과 JPA가 등장하게 되었다.

---

# ORM(Object Relational Mapping)
객체지향 언어와 관계형 DB와의 데이터를 매핑하는 기술을 의미한다.   
객체지향 언어와 관계형 DB는 서로 다른 구조를 가지고 있기 때문에 자바가 가지는 여러 이점을 제대로 사용할 수 없다.   
이를 해결하고자 나온 기술이 테이블과 객체를 매핑시켜주는 ORM이다. 

-> ORM을 사용하면 자바의 객체와 RDB의 테이블을 연결하여 사용할 수 있다.

---
# Hibernate Framework
ORM기술을 구현해 놓은 오픈소스 프레임워크이다.   
자바에서 사용가능한 ORM프레임 워크는 여러가지 있으며, 그중 Hibernate가 많이 사용된다. 

# JPA(Java Persistence API)
자바에서 ORM을 사용하기 위한 표준 API다.   
ORM 프레임워크는 여러가지가 존재하기 때문에 프레임워크를 직접 사용하면 각각의 사용방식이 달라 ORM을 변경할 때 기존 코드 수정, 사용방법을 재학습 해야하는 문제점이 있다. (특정 프레임워크에 의존하게 됨)
이런 문제점을 해결하기위해 표준 인터페이스를 제공하는 JPA가 도입되었으며, JPA를 사용하면 어떤 ORM프레임워크를 사용하더라도 동일한 방식으로 사용할 수 있다. 이로 인해 개발자들은 ORM프레임워크 간의  호환성 문제를 크게 고려하지 않고 코드 작성에 집중할 수 있다.

JPA는 인터페이스를 제공하는 역할을하며 실질적인 ORM기술을 구현해 놓은것은 Hibernate같은 ORM 프레임워크이다.

# Spring Data JPA
JPA를 기반으로 만든 모듈이다.   
Repository라는 인터페이스를 제공하여 DB와의 상호작용을 더 쉽고 간결하게 만들어준다. 내부적으로는 JPA를 사요하기 떄문에 JPA에 대한 선행학습이 필요하다.

---

# Hibernate의 ddlAuto 옵션
1. create   
   어플리케이션 실행 시, 매핑된 테이블을 삭제하고 새로 만든다.   
   (기존 데이터 전부 날아감)

2. create-drop   
   create와 동일하고 어플 종료 시 테이블을 다시 삭제 처리한다.

3. none   
   하이버테이트가 ddl에 관여하지 않는다.

4. update   
   어플 실행 시 매핑된 테이블과 객체가 동일한지 확인한다. 변경사항이 있다면 테이블에 적용하며, 기존 데이터는 유지된다.

5. validate   
   어플 실행 시, 매핑된 데이블이 객체와 동일한지 검증한다. 일치하지 않으면 실행되지 않는다.


## 영속성 컨텍스트
영속성 컨텍스트는 엔티티를 @ID가 붙은 필드로 구분하며, 이 필드를 실별자 라고 부른다. 실별자는 테이블의 PK와 매핑된다.   
엔티티가 영속성 컨텍스트에 저장되면 영속상태가 되는데 영속상태의 엔티티는 반드시 식별자가 존재해야한다. (없으면 예외 발생)   
영속성 컨텍스트에 엔티티가 저장되거나 이미 영속 상태인 엔티티가 수정되면 트랜잭션이 커밋되는 순간 엔티티의 상태를 DB에 반영하며 이를 flush라고 한다. 

### 엔티티의 상태
1. 영속   
   영속성 컨텍스트에 저장된 상태이며, 엔티티 매니저의 persist()같은 메소드를활용하여 저장할 수 있다. 영속상태가 되면 영속성 컨텍스트가 해당 엔티티를 관리하며 DB와 연결되어있는 상태이다. 영속상태가 되기 위해서는 반드시 식별자 값이 있어야한다.

2. 준영속   
   영속성 컨텍스트에 저장되었다가 분리된 상태   
   영속성 컨텍스트가 관리하다가 어떤 이유로 더 이상 관리하지 않게되면 준영속 상태가 된다. 준영속 상태는 관리대상이 아니기 때문에 변경사항이 DB에 반영되지 않는다.

3. 비영속   
   영속성 컨텍스트와 무관한 상태이다.   
   보통 엔티티 객체를 만들기만 하고 영속성 컨텍스트에 저장하지 않은 상태이다.   
   관리대상이 아니기 때문에 변경사항이 DB에 반영되지 않는다.

4. 삭제   
엔티티를 영속성 컨텍스트와 DB에서 삭제한 상태이다.




